import type { RsbuildPlugin } from '@rsbuild/core'
import { writeFileSync } from 'node:fs'
import path from 'node:path'
import oxc from 'oxc-parser'
import { normalizePath } from 'unplugin-utils'

function getType(invokeExpose: string[], listenerExpose: string[]) {
  return `/* eslint-disable */
// @ts-nocheck
// Generated by unplugin-tipc
// biome-ignore lint: disable
export {}

declare module '@byc/tipc' {
  interface TipcInvokeExpose {
    ${invokeExpose.join('\n    ')}
  }

  interface TipcListenerExpose {
    ${listenerExpose.join('\n    ')}
  }
}
`
}

export default function (): RsbuildPlugin {
  const map = new Map<string, { from: string, import: string, default: boolean }>()
  return {
    name: 'unplugin-tipc',
    setup: async (api) => {
      const rootPath = api.context.rootPath
      api.transform({ test: /\.ts$/ }, ({ code, resourcePath }) => {
        const result = oxc.parseSync(path.basename(resourcePath), code)

        result.program.body.forEach((exportDecl) => {
          if (exportDecl.type === 'ExportNamedDeclaration'
            && exportDecl.declaration?.type === 'VariableDeclaration') {
            exportDecl.declaration.declarations.forEach((declaration) => {
              // Check if declaration is a defineTipc call
              if (declaration.id.type === 'Identifier'
                && declaration.init?.type === 'CallExpression'
                && declaration.init.callee.type === 'Identifier'
                && declaration.init.callee.name === 'defineSchema') {
                const firstArg = declaration.init.arguments[0]
                if (firstArg.type !== 'Literal')
                  return

                if (typeof firstArg.value !== 'string')
                  return

                map.set(firstArg.value, {
                  default: false,
                  from: path.relative(rootPath, resourcePath),
                  import: declaration.id.name,
                })
              }
            })
          }
        })
        return code
      })

      api.onBeforeBuild(() => map.clear())

      api.onAfterBuild(() => {
        const handlers: string[] = []
        const listeners: string[] = []

        for (const [key, value] of map) {
          const item = `${key}: typeof import('./${normalizePath(value.from)}')['${value.import}']`
          handlers.push(`${item}['handlers']`)
          listeners.push(`${item}['listeners']`)
        }

        writeFileSync(path.resolve(rootPath, 'tipc.d.ts'), getType(handlers, listeners))
      })
    },
  }
}
